<!DOCTYPE html>
<html>
    <head>
        <title>Dependency Injection slowness solved by Doctrine Proxies</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="https://ocramius.github.io/components/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
        <link href="https://ocramius.github.io/components/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" />
        <link href="https://ocramius.github.io/font/stylesheet.css" rel="stylesheet" type="text/css" />
        <link href="https://ocramius.github.io/css/menu_bubble.css" rel="stylesheet" type="text/css" />
        <link rel="stylesheet" type="text/css" href="https://ocramius.github.io/css/normalize.css" />
        <link rel="stylesheet" type="text/css" href="https://ocramius.github.io/css/demo.css" />
        <link rel="stylesheet" type="text/css" href="https://ocramius.github.io/font/font-awesome-4.2.0/css/font-awesome.min.css" />
        <link href="https://ocramius.github.io/img/marco-pivetta-ocramius.gif" rel="shortcut icon"/>
        <link rel="stylesheet" href="https://ocramius.github.io/components/highlightjs/styles/github.css" />
        <link href="https://ocramius.github.io/css/style.css" rel="stylesheet" type="text/css" />
        <link rel="alternate" type="application/atom+xml" href="https://ocramius.github.io/atom.xml" title=" activity feed" />
    </head>
    <script src="https://ocramius.github.io/js/snap.svg-min.js"></script>
    <body>
        <div class="container">

            <div class='menu-wrap'>
                <nav class="menu">
                    <div class="icon-list">
                        <a href="https://ocramius.github.io/"><i class="fa fa-fw fa-newspaper-o"></i><span>Latest Posts</span></a>
                        <a href="https://ocramius.github.io/blog"><i class="fa fa-fw fa-comment-o"></i><span>Archive</span></a>
                        <a href="https://ocramius.github.io/talks"><i class="fa fa-fw fa-youtube"></i><span>Presentations</span></a>
                        <a href="https://ocramius.github.io/joindin"><i class="fa fa-fw fa-star-o"></i><span>Talks</span></a>
                        <a href="https://ocramius.github.io/about"><i class="fa fa-fw fa-user"></i><span>About</span></a>                        <a href="https://twitter.com/Ocramius" rel="me" title="Ocramius twitter profile" target="_blank"><i class="fa fa-fw fa-twitter"></i><span>Twitter</span></a>                        <a href="https://github.com/Ocramius" rel="me" title="Ocramius github profile" target="_blank"><i class="fa fa-fw fa-github"></i><span>Github</span></a>                    </div>
                </nav>                <button class="close-button" id="close-button">Close Menu</button>                <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
                    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                        <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
                    </svg>
                </div>
            </div>            <button class="menu-button" id="open-button">Open Menu</button>
            <div class="content-wrap">
                <div class="content">
                    <div class="top left">
                        <p id="shield-container" class="logo-cont left" style="width: 200px; padding: 0; margin: 0; height: 200px;
"></p>                        <h2 class="left text-center">Marco Pivetta <span>(<a href="//twitter.com/Ocramius" target="blank">Ocramius</a>)</span></h2>                    </div>

                    <div class="clear"></div>
                    <p class="text-center remove-margin">
                        <img src="https://ocramius.github.io/img/separator.png" alt=""/>
                    </p>
                    <div class="row-fluid">
                        <div class="span12">    <article>
        <header>
            <h1>Dependency Injection slowness solved by Doctrine Proxies</h1>
        </header>
        <div><h2>Dependency Injection Containers and Performance</h2>

<p>
    <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank">Dependency Injection Containers</a>
    are a vital tool for developers of complex and modular applications.
    <br/>
    Using a Dependency Injection Container in your application brings you great benefits, allowing you to compose
    complex object graphs without compromises or unnecessary ugliness (i.e. static methods).
</p>

<p>
    By using a Dependency Injection Container you automatically gain some unlocked benefits:
</p>

<dl>
    <dt><strong>Absence of hardcoded dependencies</strong>:</dt>
    <dd>
        Your objects do not handle instantiation of their dependencies, so you have one less problem to handle.
    </dd>
    <dt><strong>Better separation of concerns</strong>:</dt>
        <dd>
            Splitting problems across multiple objects becomes easier as the container helps you gluing them all
            together.
        </dd>
    <dt><strong>Mocking is much easier</strong>:</dt>
    <dd>
        Since you compose your instances with other dependencies that solve
        small problems, mocking those objects becomes really easy, and so writing tests for your application.
    </dd>
</dl>

<p>
    But there is one major pitfall: since your objects do not handle instantiation of their dependencies anymore
    <strong>you are now building huge object graphs, even if you're not using all of those objects</strong>.
    <br/>
    Take for example the following code:
</p>

<pre><code class="php">&lt;?php

class A {}

class B {}

class C {}

class D {
    public function __construct(A $a, B $b, C $c)
    {
        // ...
    }
}

class HelloWorld
{
    public function __construct(D $d)
    {
        // ...
    }

    public function sayHello()
    {
        return 'Hello World';
    }
}
</code></pre>

<p>
    The example is obviously nonsense, but this actually happens in your MVC controllers, where you may have 3 or 4
    actions and none of them using all of the dependencies of the controller itself.
</p>

<p>
    As you notice, to call <code>HelloWorld#sayHello()</code> we are required to instantiate 5 objects:
    <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>HelloWorld</code>.
</p>

<p>
    While this is robust code that will hardly break if <code>A</code>, <code>B</code>, <code>C</code> and
    <code>D</code> are correctly unit-tested, we are obviously having performance issues.
    <br/>
    Those issues become particularly noticeable when one of these objects needs to allocate a lot of resources or
    to perform costly operations such as opening a file or a socket to a remote machine.
</p>

<p>
    Using pure dependency injection yields stability, but introduces performance drawbacks, especially in
    PHP, where the object graph is rebuilt on each dispatched request.
</p>

<hr/>

<p><br/></p>

<h2>Service Location (to the rescue?)</h2>

<p>
    To solve the performance issues, some may be tempted to start using a
    <a href="https://martinfowler.com/articles/injection.html#UsingAServiceLocator" target="_blank">Service Locator</a>
    within their services:
</p>

<pre><code class="php">&lt;?php

class HelloWorld
{
    public function __construct(ServiceLocator $serviceLocator)
    {
        $this-&gt;serviceLocator = $serviceLocator;
    }

    public function sayHello()
    {
        return 'Hello World';
    }

    public function doSomethingWithD()
    {
        if ( ! $this-&gt;d) {
            $this-&gt;d = $this-&gt;serviceLocator-&gt;get('D');
        }

        $this-&gt;d-&gt;doSomething();
    }
}
</code></pre>

<p>
    As you have noticed, this solves the performance issue by allowing us to retrieve an instance of <code>D</code>
    <strong>only when we really need it</strong>:
    <br/>
    performance!
</p>

<p>
    Anyway, by doing so we introduced some new problems:
</p>

<dl>
    <dt><strong>Our object cannot exist without a service locator</strong>:</dt>
    <dd>
        makes testability hard, since we will need to mock the service locator in order to test
        <code>HelloWorld</code>, and mocking a service locator is not so easy.
    </dd>
    <dt><strong>Our object depends on the implementation of the service locator</strong>:</dt>
    <dd>
        portability of our code is reduced, since it will work only with a specific service locator implementing the
        <code>ServiceLocator</code> contract.
    </dd>
    <dt><strong>Instantiation of dependencies moved to our code</strong>:</dt>
    <dd>
        instantiation of <code>D</code> should not be a problem solved by our code. We introduced it in our code
        now, so we must test it.
    </dd>
    <dt><strong>Hardcoded service name in our code</strong>:</dt>
    <dd>
        This makes our class very error prone if we don't write extensive integration tests each time we ship our
        code. Also, it makes our code incompatible with anything sharing the same
        <code>ServiceLocator</code> instance and requiring an instance named <code>'D'</code>, but with different
        expectations.
    </dd>
</dl>

<p>
    We solved a performance problem to introduce at least <strong>4 new ones!</strong>
    <br/>
    Not really nice, eh? Not at all.
</p>

<p>
    If you are already using service location, <strong>STOP DOING IT NOW</strong> and please read the rest of this
    post.
</p>

<p>
    There must be a <em>better</em> solution... After all, what we want to avoid is instantiating
    <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> alltogether if we aren't using them.
    <br/>
    Doesn't sound to be so hard!
</p>

<hr/>

<p><br/></p>

<h2>Doctrine Proxies to the rescue!</h2>

<p>
    The idea is not new, and <a href="http://pooteeweet.org/" target="_blank">Lukas Smith</a> already
    <a href="https://github.com/symfony/symfony/issues/5012" target="_blank">discussed it on the Symfony2 issue
    tracker</a>.
</p>

<p>
    Since I was already playing around with code generation for doctrine, I decided to implement those concepts
    with <strong>Doctrine Proxies</strong>.
</p>

<hr/>

<p><br/></p>

<h2>What are Doctrine Proxies?</h2>

<p>
    <a href="https://github.com/Ocramius/common/blob/DCOM-96/lib/Doctrine/Common/Proxy/Proxy.php"
    target="_blank">Doctrine Proxies</a> are a PHP implementation of the
    <a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank">proxy pattern</a> used to achieve
    <a href="https://www.martinfowler.com/eaaCatalog/lazyLoad.html" target="_blank">lazy loading</a> of objects from
    a persistent storage.
    <br/>
    Doctrine implements this pattern by having <strong>Virtual Proxies</strong> that behave like
    <strong>Ghost Objects</strong>.
</p>

<p>
    The concept behind proxies is quite simple: each time a method of the proxy is called, if the proxy is not
    initialized, initialization logic is triggered (which usually corresponds to filling its fields with data
    coming from a DB).
    <br/>
    After that, the original code that was supposed to be executed with that method call is run.
</p>

<p>
    This is achieved by Doctrine by generating a class that inherits from the original object and faking all of
    its public API and adding the required code to trigger lazy loading:
</p>

<pre><code class="php">&lt;?php

class UserProxy extends User
{
    protected $initialized = false;

    public function getUsername()
    {
        if ( ! $this-&gt;initialized) {
            initialize($this);
        }

        return parent::getUsername();
    }
}
</code></pre>

<p>
    The previous snippet is just a simplified example, and isn't very flexible, but as you may know, Doctrine is a
    set of libraries focusing on persistence of data, and the
    <a href="https://github.com/doctrine/common/blob/8b403cde97eaede30bd79acab4f18895fd5bdf27/lib/Doctrine/Common/Persistence/Proxy.php"
    target="_blank">first version of proxies</a> was highly focused on supporting the purpose of loading an object
    from a database.
</p>

<p>
    The implementation has been enhanced with <a href="https://github.com/doctrine/common/pull/168" target="_blank">
    a patch I'm working on</a>, now allowing many different uses of the proxy pattern. This is mainly possible
    because of <a href="https://secure.php.net/manual/en/functions.anonymous.php" target="_blank">lambda functions</a>
    used as initialization logic holders:
</p>

<pre><code class="php">&lt;?php

class UserProxy extends User
{
    /** @var Closure */
    protected $initializer;

    public function __setInitializer(Closure $initializer)
    {
        $this-&gt;initializer = $initializer;
    }

    public function getUsername()
    {
        if ($this-&gt;initializer !== null) {
            call_user_func($this-&gt;initializer);
        }

        return parent::getUsername();
    }
}
</code></pre>

<p>
    Using a <a href="https://secure.php.net/manual/en/class.closure.php" target="_blank">Closure</a> as an initializer
    now enables us to swap the initialization logic used for our proxy object. I won't get into details, but this
    is a requirement for our next step.
</p>

<hr/>

<p><br/></p>

<h2>Why proxies?</h2>

<p>
    Let's get back to the example with <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,
    <code>HelloWorld</code>, but we'll introduce a proxy now:
</p>

<pre><code class="php">&lt;?php

class A {}

class B {}

class C {}

class D
{
    public function __construct(A $a, B $b, C $c)
    {
        // ...
    }

    public function doSomething()
    {
        return 'Did something with ' . $this-&gt;a . ', ' . $this-&gt;b . ', ' . $this-&gt;c;
    }
}

class D_Proxy extends D
{
    private $serviceLocator;
    private $original;

    public function __construct(ServiceLocator $serviceLocator)
    {
        $this-&gt;serviceLocator = $serviceLocator;
    }

    private function initialize()
    {
        $this-&gt;initialized = true;
        $this-&gt;original    = $this-&gt;serviceLocator-&gt;get('D');
    }

    public function doSomething()
    {
        if ( ! $this-&gt;initialized) {
            $this-&gt;initialize();
        }

        return $this-&gt;original-&gt;doSomething();
    }
}

class HelloWorld
{
    public function __construct(D $d)
    {
        // ...
    }

    public function sayHello()
    {
        return 'Hello World';
    }

    public function doSomethingWithD()
    {
        return $this-&gt;d-&gt;doSomething();
    }
}
</code></pre>

<p>
    Wait... What? Ok, let's slow this down a bit:
</p>

<ol>
    <li>
        You can now pass an instance of <code>D_Proxy</code> to <code>HelloWorld</code>. Since <code>D_Proxy</code>
        extends <code>D</code>, it respects the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"
        target="_blank">Liskov substitution principle</a>.
    </li>
    <li>
        The proxy is uninitialized, and it is empty (we have replaced its constructor).
    </li>
    <li>
        When <code>doSomething</code> is called on the proxy, the real instance of <code>D</code> is retrieved
        from a service locator, and put into the <code>original</code> property.
    </li>
    <li>
        The method call is proxied to <code>$this->original->doSomething();</code>.
    </li>
    <li>
        Since the original object is fully populated with instances of <code>A</code>, <code>B</code> and
        <code>C</code>, code works as expected.
    </li>
</ol>

<p>
    We successfully avoided instantiating <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> when
    calling <code>sayHello</code>! <em>Awesome!</em>
</p>

<p>
    But wait: didn't I just say that service location is evil?
</p>

<p>
    Yes it is, but <code>D_Proxy</code> is generated code (don't worry about how it is generated) and:
</p>

<ul>
    <li>
        Its code generation is based on how the dependency injection container defined that <code>D</code> should
        be instantiated, thus the hardcoded <code>'D'</code> within the proxy code comes from the current DIC
        definitions. This allows it to have our DIC handling collisions between service names, and hardcoded
        magic strings disappear from our code base.
    </li>
    <li>
        It abstracts the problem of lazy initialization of a service for us. The generated code doesn't need
        to be tested as that is something done by the implementor of the proxy generator (me).
    </li>
    <li>
        It has the same performance impact of introducing lazy initialization logic in our classes' methods (similar
        amount of system calls).
    </li>
    <li>
        Turning on or off proxies does not change the functionality provided by our applications. They're just
        a performance tweak. They do not affect how our logic is dispatched.
    </li>
    <li>
        Proxies actually allow cyclic dependencies. Since objects are lazily initialized, if <code>A</code> depends
        on <code>B</code>, and <code>B</code> depends on <code>A</code>, and one of those two is proxied, the lazy
        initialization mechanism will prevent us from triggering an infinite loop in our instantiation logic. This
        is actually a thing I didn't think of initially, but it turns out to be a nice and powerful side effect.
    </li>
</ul>

<hr/>

<h2>General usage directions</h2>

<p>
    Proxies also have some limitations though:
</p>

<dl>
    <dt><strong>Cannot benefit from the initializer pattern/setter injection</strong>:</dt>
    <dd>
        since any call to a proxy method that isn't its constructor would cause its initialization, setter injection
        cannot be used on a proxy, or it will basically render the underlying idea of performance tweak useless.
    </dd>
    <dt><strong>Cannot proxy dynamic services</strong>:</dt>
    <dd>
        you can apply this proxy pattern only when assuming that calling <code>$serviceLocator-&gt;get('D');</code>
        will actually return an instance of <code>D</code>. If the return type varies depending on i.e. environment
        variables, this code will break.
    </dd>
    <dt><strong>Must be synchronized</strong>:</dt>
    <dd>
        changing implementation of our services requires us to re-generate proxies so that they respect the contract
        of the service class. Since generated code in PHP is hard to put into a cache (because opcode caches cannot
        act on serialized data) we need to save proxies to predictable location in our system in order to autoload
        them and avoid generating them over and over. That also means that we have to delete them when we change our
        code, so that we can let the generator rewrite them.
    </dd>
    <dt><strong>Add constant overhead to method calls</strong>:</dt>
    <dd>
        If your object is lightweight, you may not need to proxy it, especially if its methods get called thousands
        of times.
    </dd>
</dl>

<hr/>

<p><br/></p>

<h2>Examples/benchmarks</h2>

<ul>
    <li>
        If you want to read further on the proxy implementation I proposed for Zend Framework 2 you can check the
        <a href="https://github.com/zendframework/zf2/pull/2995" target="_blank">corresponding pull request</a>.
    </li>
    <li>
        If you are interested in how proxy generation works in Doctrine, you can check
        <a href="https://github.com/doctrine/common/pull/168" target="_blank">my current work</a> on doctrine common.
    </li>
    <li>
        If performance is your concern, read about the results of the last PHPPeru hack day I had with cordoval in
        <a href="http://www.craftitonline.com/2012/11/lazy-load-services-and-do-not-inject-the-container-into-them/"
        target="_blank">his blog</a>.
    </li>
    <li>
        I am also starting work to implement this idea for Symfony 2 too. Not quite there yet :-)
    </li>
</ul>

<hr/>

<p><br/></p>

<h2>Conclusions</h2>

<p>
    I can conclude that the proxies are a good solution to solve the performance issues that are introduced by
    Dependency Injection Containers. They also allow us to completely get rid of service location and to focus
    on writing clean and robust classes that are easy to test.
</p>

<p>
    They surely add some hidden magic to our code, and I've been already told by <a href="https://mwop.net/" target="_blank">
    Matthew Weier 'o Phinney</a> that some newcomers may be confused by the additional calls they will in stack
    traces when looking at exceptions. Since proxies are an optional feature, I'm not really concerned about it.
</p>

<p>
    I also worked with <a href="http://www.craftitonline.com/2012/11/lazy-load-services-and-do-not-inject-the-container-into-them/"
    target="_blank">Luis Cordova</a> in organizing the topics for the last PHPPeru hack day, and the participants
    didn't have big problems in understanding the problems and solutions suggested by the proxy approach, so I'm
    quite confident about having it adopted in ZF2 and SF2 soon.
</p>

<p>
    Anyway, proxies are not a requirement to get our application working. They are just steroids for our services,
    and I'd surely suggest you to use them.
</p>
        </div>            <p class="tags">
            Tags:            <a href="https://ocramius.github.io/blog/tags/zend">zend</a>,            <a href="https://ocramius.github.io/blog/tags/zendframework">zendframework</a>,            <a href="https://ocramius.github.io/blog/tags/zf2">zf2</a>,            <a href="https://ocramius.github.io/blog/tags/symfony">symfony</a>,            <a href="https://ocramius.github.io/blog/tags/doctrine">doctrine</a>,            <a href="https://ocramius.github.io/blog/tags/dependency%20injection">dependency injection</a>,            <a href="https://ocramius.github.io/blog/tags/service%20location">service location</a>,            <a href="https://ocramius.github.io/blog/tags/proxies">proxies</a>            </p>            <nav class="article">
                <ul>                        <li>Next: <a class="next" href="https://ocramius.github.io/blog/proxy-pattern-in-php" title="The Proxy Pattern in PHP"><span class="title">The Proxy Pattern in PHP</span></a></li>                        <li>Previous: <a class="previous" href="https://ocramius.github.io/blog/asset-manager-for-zend-framework-2" title="JS/CSS/Images with Zend Framework 2 and the Asset Manager Module"><span class="title">JS/CSS/Images with Zend Framework 2 and the Asset Manager Module</span></a></li>                </ul>
            </nav>        </article>        <div data-tweet-id="270851711395045377" class="twitter-tweet"></div>        
        <div id="disqus_thread"></div>

        <script>
            if (typeof prettyPrint !== 'undefined') {
                $(prettyPrint);
            }
        </script>
        <script>
            var disqus_shortname = 'ocramius-dev';
            var disqus_identifier = '/blog/zf2-and-symfony-service-proxies-with-doctrine-proxies';
            var disqus_url = 'https://ocramius.github.io/blog/zf2-and-symfony-service-proxies-with-doctrine-proxies';
        </script>
        <script src="https://ocramius-dev.disqus.com/count.js"></script>
        <script src="https://ocramius-dev.disqus.com/embed.js"></script>                        </div>
                        <div class="span4 si debar"></div>
                   </div>
                </div>
            </div>

        </div>

        <script src="https://ocramius.github.io/js/shifty.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r66/three.min.js"></script>
        <script src="https://ocramius.github.io/components/bootstrap/js/bootstrap.min.js"></script>
        <script src="https://ocramius.github.io/components/jquery/jquery.min.js"></script>
        <script src ="https://ocramius.github.io/js/blogpost-tweets.js" type="text/javascript"></script>
        <script src="https://platform.twitter.com/widgets.js"></script>        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-33922165-1', 'auto');
            ga('send', 'pageview');
        </script>
        <script src="https://ocramius.github.io/components/highlightjs/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script src="https://ocramius.github.io/js/classie.js"></script>
        <script src="https://ocramius.github.io/js/main4.js"></script>
        <script src="https://ocramius.github.io/js/three-js-object-loader.js"></script>
        <script src="https://ocramius.github.io/js/mario.js"></script>
        <script>mario($('#shield-container'), "https://ocramius.github.io/logo/mario");</script>
    </body>
</html>
